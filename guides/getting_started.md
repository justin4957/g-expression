# Getting Started with G-Expressions

This tutorial will walk you through testing the G-Expression system from scratch, demonstrating all the key concepts and practical applications.

## Prerequisites

Ensure you have Elixir 1.18+ installed:

```bash
elixir --version
# Elixir 1.18.4 (compiled with Erlang/OTP 27)
```

## Step 1: Basic Setup and First Tests

Clone and set up the project:

```bash
git clone <your-repo>
cd gexpression
mix deps.get
mix compile
```

Let's start with an interactive Elixir session to test the system:

```bash
iex -S mix
```

### Test the Prime Mover

```elixir
# Bootstrap the basic system
{:ok, context} = Gexpr.bootstrap()

# Test literal evaluation
Gexpr.eval({:lit, 42}, context)
#=> {:ok, 42}

# Test reference lookup
Gexpr.eval({:ref, "id"}, context) 
#=> {:ok, {:builtin, "id", #Function<...>}}

# Test function application
Gexpr.eval({:app, {:ref, "id"}, {:lit, "hello"}}, context)
#=> {:ok, "hello"}

# Test arithmetic
add_expr = {:app, {:ref, "+"}, {:vec, [{:lit, 20}, {:lit, 22}]}}
Gexpr.eval(add_expr, context)
#=> {:ok, 42}
```

## Step 2: Lambda Calculus and Closures

Test lambda creation and application:

```elixir
# Create identity function
id_lambda = {:lam, %{params: ["x"], body: {:ref, "x"}}}
{:ok, id_func} = Gexpr.eval(id_lambda, context)

# Apply it
Gexpr.PrimeMover.apply_value(id_func, [42])
#=> {:ok, 42}

# Create and apply add function
add_lambda = {:lam, %{
  params: ["x", "y"], 
  body: {:app, {:ref, "+"}, {:vec, [{:ref, "x"}, {:ref, "y"}]}}
}}

add_app = {:app, add_lambda, {:vec, [{:lit, 10}, {:lit, 20}]}}
Gexpr.eval(add_app, context)
#=> {:ok, 30}
```

## Step 3: The Y-Combinator (Recursion)

Test recursive factorial computation:

```elixir
# Define factorial using fix combinator
factorial_body = {:lam, %{
  params: ["n"],
  body: {:match, {:app, {:ref, "<="}, {:vec, [{:ref, "n"}, {:lit, 1}]}}, [
    {{:lit_pattern, true}, {:lit, 1}},
    {:else_pattern, {:app, {:ref, "*"}, {:vec, [
      {:ref, "n"},
      {:app, {:ref, "f"}, {:vec, [{:app, {:ref, "-"}, {:vec, [{:ref, "n"}, {:lit, 1}]}}]}}
    ]}}}
  ]}
}}

factorial_generator = {:lam, %{params: ["f"], body: factorial_body}}
factorial_fixed = {:fix, factorial_generator}

# Test factorial of 5
fact_5 = {:app, factorial_fixed, {:vec, [{:lit, 5}]}}
Gexpr.eval(fact_5, context)
#=> {:ok, 120}

# Test factorial of 0 (base case)  
fact_0 = {:app, factorial_fixed, {:vec, [{:lit, 0}]}}
Gexpr.eval(fact_0, context)
#=> {:ok, 1}
```

## Step 4: Macro Library

Load and test the macro library:

```elixir
# Bootstrap with macros
{:ok, macro_context} = Gexpr.bootstrap_with_macros()

# Test increment macro
inc_expr = {:app, {:ref, "inc"}, {:vec, [{:lit, 41}]}}
Gexpr.eval(inc_expr, macro_context)
#=> {:ok, 42}

# Test square macro
square_expr = {:app, {:ref, "square"}, {:vec, [{:lit, 6}]}}
Gexpr.eval(square_expr, macro_context)
#=> {:ok, 36}

# Test function composition: compose(square, inc)(5) = square(inc(5)) = square(6) = 36
compose_expr = {:app,
  {:app, {:ref, "compose"}, {:vec, [{:ref, "square"}, {:ref, "inc"}]}},
  {:vec, [{:lit, 5}]}
}
Gexpr.eval(compose_expr, macro_context)
#=> {:ok, 36}

# Test when macro (conditional execution)
when_expr = {:app, {:ref, "when"}, {:vec, [{:lit, true}, {:lit, "executed!"}]}}
Gexpr.eval(when_expr, macro_context)
#=> {:ok, "executed!"}

# Test logical operations
and_expr = {:app, {:ref, "and"}, {:vec, [{:lit, true}, {:lit, false}]}}
Gexpr.eval(and_expr, macro_context)
#=> {:ok, false}
```

## Step 5: AI-Friendly Generation

Test AI prompt processing:

```elixir
# Generate G-Expression from natural language
{:ok, ai_result} = Gexpr.generate_from_ai_prompt("add 20 and 22")

# Inspect the generated structure
IO.inspect(ai_result, pretty: true)
#=> %{
#     "g" => "app",
#     "v" => %{...},
#     "m" => %{
#       "generated_by" => "simulated_ai_v1.0",
#       "source_prompt" => "add 20 and 22",
#       "confidence" => 0.9,
#       ...
#     }
#   }

# Convert to JSON for AI processing
{:ok, json_str} = Gexpr.to_ai_json(ai_result)
IO.puts(json_str)

# Parse back from JSON
{:ok, parsed} = Gexpr.parse_ai_json(json_str)

# Execute the parsed expression
# (Convert AI format to internal format first)
internal_expr = convert_ai_to_internal(parsed)
{:ok, context} = Gexpr.bootstrap()
Gexpr.eval(internal_expr, context)
#=> {:ok, 42}
```

## Step 6: Metadata and Provenance

Test computation archaeology features:

```elixir
# Add AI provenance to a G-Expression
gexpr = %{"g" => "lit", "v" => 42}
with_metadata = Gexpr.add_ai_metadata(
  gexpr, 
  "gpt-4", 
  "create the answer to everything", 
  0.95
)

# Generate provenance report
report = Gexpr.provenance_report(with_metadata)
IO.puts(report)
#=> G-Expression Provenance Report
#   ==============================
#   
#   Generated By: gpt-4
#   Timestamp: 2024-01-01T12:00:00Z
#   Source: create the answer to everything
#   Confidence: 0.95
#   ...

# Create audit trail
audit = Gexpr.Metadata.create_audit_trail(with_metadata)
IO.inspect(audit, pretty: true)
```

## Step 7: Running the Complete Test Suite

Exit IEx and run the full test suite:

```bash
# Run core functionality tests
mix test test/gexpr/prime_mover_test.exs

# Run macro library tests
mix test test/gexpr/macro_library_test.exs

# Run AI integration tests
mix test test/gexpr/ai_generator_test.exs

# Run bootstrap tests
mix test test/gexpr/bootstrap_test.exs

# Run all tests (excluding slow recursive ones)
mix test --exclude slow
```

## Step 8: Advanced Examples

### Church Encodings

```elixir
{:ok, context} = Gexpr.bootstrap()

# Church true = λx.λy.x
church_true = {:lam, %{params: ["x", "y"], body: {:ref, "x"}}}

# Test: church_true("first", "second") should return "first"
true_test = {:app, church_true, {:vec, [{:lit, "first"}, {:lit, "second"}]}}
Gexpr.eval(true_test, context)
#=> {:ok, "first"}
```

### Self-Modifying Code

```elixir
{:ok, macro_context} = Gexpr.bootstrap_with_macros()

# Function that generates other functions: make_adder = λn.λx. x + n
make_adder = {:lam, %{
  params: ["n"],
  body: {:lam, %{
    params: ["x"], 
    body: {:app, {:ref, "+"}, {:vec, [{:ref, "x"}, {:ref, "n"}]}}
  }}
}}

# Generate add5 function
add5_gen = {:app, make_adder, {:vec, [{:lit, 5}]}}
{:ok, add5_func} = Gexpr.eval(add5_gen, macro_context)

# Use generated function
Gexpr.PrimeMover.apply_value(add5_func, [37])
#=> {:ok, 42}
```

### Complex Macro Chaining

```elixir
{:ok, macro_context} = Gexpr.bootstrap_with_macros()

# Chain multiple macros: when(>(square(5), 20), inc(10))
# Should compute: when(>(25, 20), 11) = when(true, 11) = 11
complex_expr = {:app, {:ref, "when"}, {:vec, [
  {:app, {:ref, ">"}, {:vec, [
    {:app, {:ref, "square"}, {:vec, [{:lit, 5}]}},
    {:lit, 20}
  ]}},
  {:app, {:ref, "inc"}, {:vec, [{:lit, 10}]}}
]}}

Gexpr.eval(complex_expr, macro_context)
#=> {:ok, 11}
```

## Step 9: Performance and Debugging

### Timing Evaluations

```elixir
{:ok, context} = Gexpr.bootstrap()

# Time a computation
:timer.tc(fn ->
  Gexpr.eval({:app, {:ref, "+"}, {:vec, [{:lit, 1000}, {:lit, 2000}]}}, context)
end)
#=> {microseconds, {:ok, 3000}}
```

### Error Handling

```elixir
# Test undefined reference
Gexpr.eval({:ref, "nonexistent"}, context)
#=> {:error, "Undefined reference: nonexistent"}

# Test arity mismatch
{:ok, macro_context} = Gexpr.bootstrap_with_macros()
Gexpr.eval({:app, {:ref, "inc"}, {:vec, [{:lit, 1}, {:lit, 2}]}}, macro_context)
#=> {:error, "Arity mismatch: expected 1, got 2"}
```

## Step 10: Documentation Generation

Generate and view the complete documentation:

```bash
mix docs
open doc/index.html  # or your OS equivalent
```

## What You've Accomplished

By following this tutorial, you have:

1. ✅ **Verified Core Semantics** - Tested all fundamental G-Expression types
2. ✅ **Demonstrated Lambda Calculus** - Created and applied closures
3. ✅ **Proven Recursion** - Used Y-combinator for factorial computation  
4. ✅ **Explored Macros** - Used pure G-Expression macro definitions
5. ✅ **Tested AI Integration** - Generated code from natural language
6. ✅ **Tracked Provenance** - Added metadata and audit trails
7. ✅ **Verified Self-Hosting** - Macros defined in terms of G-Expressions
8. ✅ **Demonstrated Composability** - Complex expressions from simple parts

## Next Steps

- **Extend the macro library** with your own definitions
- **Create custom AI prompts** and test generation accuracy
- **Implement new builtin operations** in the Prime Mover
- **Add your own metadata fields** for specific use cases
- **Experiment with Church encodings** and lambda calculus
- **Build domain-specific languages** on top of G-Expressions

## Troubleshooting

### Common Issues

1. **Pattern matching errors**: Ensure tuples use `{{pattern}, expr}` format
2. **Arity mismatches**: Check function parameter counts match arguments
3. **Infinite recursion**: Add proper base cases to recursive functions
4. **Reference errors**: Verify all referenced names exist in context

### Debug Techniques

```elixir
# Inspect intermediate results
{:ok, result} = Gexpr.eval(some_expr, context)
IO.inspect(result, pretty: true)

# Check context contents
IO.inspect(Map.keys(context))

# Trace evaluation steps (add debugging to unfurl functions)
```

Congratulations! You now have a complete understanding of the G-Expression system and can explore its full potential for AI-native computing, self-hosting systems, and computational archaeology.